import{fR as b,bw as d,fS as R,fT as X,f1 as Y,fU as v,fa as _,fV as k,fW as j,fX as q,fY as w,fZ as A,f_ as B}from"./index-BF2r6OBf.js";import{c as C}from"./GraphicManipulator-fJpiw2zD.js";function P(n,e,s,t){if(n.type==="point")return n.x+=e,n.y+=s,n.hasZ&&t!=null,n;if(n.type==="multipoint"){const r=n.points;for(let o=0;o<r.length;o++)r[o]=z(r[o],e,s,t);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=s,n.ymax+=s,n;const i=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,c=k(n);for(let r=0;r<i.length;r++){const o=i[r];for(let m=0;m<o.length;m++)o[m]=E(o[m],e,s,t)}return"paths"in n?c?n.curvePaths=i:n.paths=i:c?n.curveRings=i:n.rings=i,n}function I(n,e,s,t,i){const c=n.clone();if(i){const{resolution:r}=t;P(c,e*r,-s*r)}else{const{dxMap:r,dyMap:o}=D(e,s,t);P(c,r,o)}return c}function D(n,e,s){const t=s.state.inverseTransform;return{dxMap:t[0]*n+t[2]*e,dyMap:t[1]*n+t[3]*e}}function z(n,e,s,t){return T(n,n[0]+e,n[1]+s,n[2]!=null&&t!=null?n[2]+t:void 0)}function E(n,e,s,t){const i=z(v(n),e,s,t);if(j(n))return i;if(q(n)){const[,o,m]=n.b;return{b:[i,[o[0]+e,o[1]+s],[m[0]+e,m[1]+s]]}}if(w(n)){const[,o]=n.c;return{c:[i,[o[0]+e,o[1]+s]]}}const[,c,...r]=n.a;return{a:[i,[c[0]+e,c[1]+s],...r]}}function J(n,e,s,t){if(n.type==="point"){const{x:f,y:a}=n,y=t?t[0]:f,l=t?t[1]:a,x=n.clone(),p=(f-y)*e+y,u=(a-l)*s+l;return x.x=p,x.y=u,x}if(n.type==="extent"){const{xmin:f,xmax:a,ymin:y,ymax:l}=n,x=t?t[0]:(f+a)/2,p=t?t[1]:(l+y)/2,u=n.clone();if(u.xmin=(f-x)*e+x,u.ymax=(l-p)*s+p,u.xmax=(a-x)*e+x,u.ymin=(y-p)*s+p,u.xmin>u.xmax){const h=u.xmin,M=u.xmax;u.xmin=M,u.xmax=h}if(u.ymin>u.ymax){const h=u.ymin,M=u.ymax;u.ymin=M,u.ymax=h}return u}let i=null;if(!t){i=b(n);const f=d(),a=R(f,i);if(!a)return n.clone();const[y,l,x,p]=a;t=[(y+x)/2,(l+p)/2]}const[c,r]=t;if(n.type==="multipoint"){const f=n.clone(),a=f.points;for(let y=0;y<a.length;y++){const l=a[y],[x,p]=l,u=(x-c)*e+c,h=(p-r)*s+r;a[y]=T(l,u,h,void 0)}return f.points=a,f}const o=n.clone();i??=b(n);const m=o.type==="polygon",g=m?o.curveRings??o.rings:o.curvePaths??o.paths;if(!t){const f=d(),a=R(f,g,!1,!1);if(!a)return o;t=X(a)}for(const f of g){let a=null;const y=m&&f.length>0&&Y(v(f[0]),v(f.at(-1)));for(let l=0;l<f.length;l++){const x=f[l];f[l]=F(x,e,s,c,r,a),a=x}y&&(f[0]=[...v(f.at(-1))])}return o}function U(n,e,s,t,i){const[c,r,...o]=n;return[(c-t)*e+t,(r-i)*s+i,...o]}function F(n,e,s,t,i,c){if(j(n))return U(n,e,s,t,i);if(q(n)){const[Z,S,V]=n.b.map(W=>U(W,e,s,t,i));return{b:[Z,S,V]}}if(!c)return n;const r=v(c),o=w(n)?A(r,n):n,[m,g,f,a,y,l,x]=o.a,p=y??0,u=l??Math.hypot(m[0]-g[0],m[1]-g[1]),h=x??1,M=C(t,i,1,0,0,1,e,s);return B(r,{a:[[...m],[...g],f,a,p,u,h]},M)}function K(n,e,s,t,i,c){const r=Math.sqrt((s-n)*(s-n)+(t-e)*(t-e));return Math.sqrt((i-n)*(i-n)+(c-e)*(c-e))/r}function L(n,e,s,t=!1){const i=Math.atan2(e.y-s.y,e.x-s.x)-Math.atan2(n.y-s.y,n.x-s.x),c=Math.atan2(Math.sin(i),Math.cos(i));return t?c:_(c)}function T(n,e,s,t){const i=[e,s];return n.length>2&&i.push(t??n[2]),n.length>3&&i.push(n[3]),i}export{J as M,K as U,L as b,D as h,I as x};
